{
  "hash": "0eb3b06661fd56c89c66ac8bcd64e0e4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fitting a Hill Function in R\"\ndescription: |\n  The first dollar spent in a marketing effort is always the highest ROI and it diminishes it's retrun from there and gets worse depending on the channel and season.  This shape is beautifully made by the Hill Function.\ncategories: [r, bayesian, marketing]\nauthor: Ben Woodard\ndate: 2025-11-16\nimage: \"/images/hill_function_example.png\"\n---\n\n## 1. The Hill Function (Generative Form)\n\nA typical Hill function:\n\n$$\ny = \\alpha \\cdot \\frac{x^n}{k^n + x^n}\n$$\n\n* α — Maximum height (how tall the curve gets)  \n* k — Midpoint (where it bends)  \n* n — Hill coefficient (curvature / steepness)\n\nInside an MMM, the Hill function becomes the functional form for the “response curve” for each marketing channel. It looks something like this:\n\n`sales ~ normal( sum(mu_j) + seasonality + promos + trend, sigma )`\n\nLet's work through an example of what that would look like.\n\n## 2. Simulate Some Data (“Before modeling, simulate the model” — McElreath)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(2025)\n\n# True parameters\nalpha_true <- 10\nk_true     <- 3\nn_true     <- 2\n\n# Predictor\nx <- seq(0, 30, length.out = 1e2)\n\n# Hill function\nhill <- function(x, alpha, k, n) {\n  alpha * (x^n / (k^n + x^n))\n}\n\ny <- hill(x, alpha_true, k_true, n_true) + rnorm(length(x), 0, 0.5)\n\ndf <- tibble(x, y)\n\nplot(df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## 3. Fit the Hill Model Using r `brms::brm`\n\nbrm handles nonlinear formulas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brms)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Rcpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading 'brms' package (version 2.22.0). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'brms'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:stats':\n\n    ar\n```\n\n\n:::\n\n```{.r .cell-code}\nhill_model <- brm(\n  bf(\n    y ~ alpha * x^n / (k^n + x^n), ##hill function\n    alpha + k + n ~ 1, ##model params  the ~ `1 is “Model each nonlinear parameter as its own intercept (no varying effects).”\n    nl = TRUE #switches brms into nonlinear model\n  ),\n  data = df,\n  family = gaussian(),\n  prior = c(\n    prior(normal(80, 3), nlpar = \"alpha\"), #max saturation level\n    prior(normal(3, 2), nlpar = \"k\"), #half-max point - controls where the curve reaches 50% of a\n    prior(normal(2, 1), nlpar = \"n\") # hill coefficient (steepness)\n  ),\n  iter = 2000,\n  chains = 4,\n  cores = 4\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling Stan program...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTrying to compile a simple C file\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB foo.c\nusing C compiler: ‘Apple clang version 17.0.0 (clang-1700.0.13.5)’\nusing SDK: ‘MacOSX15.5.sdk’\nclang -arch arm64 -I\"/Library/Frameworks/R.framework/Resources/include\" -DNDEBUG   -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/Rcpp/include/\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppEigen/include/\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppEigen/include/unsupported\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/BH/include\" -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/StanHeaders/include/src/\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/StanHeaders/include/\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppParallel/include/\"  -I\"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/opt/R/arm64/include    -fPIC  -falign-functions=64 -Wall -g -O2  -c foo.c -o foo.o\nIn file included from <built-in>:1:\nIn file included from /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp:22:\nIn file included from /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppEigen/include/Eigen/Dense:1:\nIn file included from /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppEigen/include/Eigen/Core:19:\n/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/RcppEigen/include/Eigen/src/Core/util/Macros.h:679:10: fatal error: 'cmath' file not found\n  679 | #include <cmath>\n      |          ^~~~~~~\n1 error generated.\nmake: *** [foo.o] Error 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStart sampling\n```\n\n\n:::\n:::\n\n\nUnder the hood the brms translates the formula to stan which looks like:\n```\nmu = alpha * pow(x, n) / (pow(k, n) + pow(x, n));\ny ~ normal(mu, sigma);\nalpha ~ normal(10, 3);\nk ~ normal(3, 2);\nn ~ normal(1, 1);\n```\n\n## 4. Review Posterior Summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(hill_model, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: y ~ alpha * x^n/(k^n + x^n) \n         alpha ~ 1\n         k ~ 1\n         n ~ 1\n   Data: df (Number of observations: 100) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nalpha_Intercept     9.98      0.10     9.80    10.20 1.00     2295     2345\nk_Intercept         2.95      0.10     2.76     3.14 1.00     3127     2228\nn_Intercept         2.01      0.14     1.74     2.28 1.00     2443     2234\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.52      0.04     0.45     0.60 1.00     3607     2817\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(hill_model)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nposterior <- as.data.frame(hill_model)\n```\n:::\n\n\nYou should see α, k, and n close to the true values 10, 3, and 1.\n\n## 5. Posterior Predictive Curve\n\nThis mirrors McElreath’s \"link\" method in Statistical Rethinking:\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_x <- tibble(x = seq(0, 30, length.out = 100))\n\npred <- rstantools::posterior_linpred(hill_model, newdata = new_x, transform = TRUE)\n\npred_mean  <- apply(pred, 2, mean)\npred_lower <- apply(pred, 2, quantile, 0.05)\npred_upper <- apply(pred, 2, quantile, 0.95)\n\nplot_df <- new_x %>% \n  mutate(mean = pred_mean,\n         lower = pred_lower,\n         upper = pred_upper)\n\nggplot() +\n  geom_point(data = df, aes(x, y), alpha = 0.5) +\n  geom_line(data = plot_df, aes(x, mean), linewidth = 1.1) +\n  geom_ribbon(data = plot_df, aes(x, ymin = lower, ymax = upper), alpha = 0.2) +\n  theme_minimal() +\n  labs(title = \"Hill Function Fit using brms\",\n       y = \"y\", x = \"x\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Notes\n\nThis is not a GLM; it's explicitly nonlinear in the parameters.\n\nGood priors matter: the Hill coefficient n is notoriously unstable without domain knowledge.\n\nPlot prior predictive before sampling if possible.\n\nAlways check if posterior curves imply sane behavior for small or large x.\n\nThink of α as “max plausible outcome,” k as “dose at half max,” and n as “bendiness.”",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}