---
title: "Fitting a Hill Function in R"
description: |
  The first dollar spent in a marketing effort is always the highest ROI and it diminishes it's retrun from there and gets worse depending on the channel and season.  This shape is beautifully made by the Hill Function.
categories: [r, bayesian, marketing]
author: Ben Woodard
date: 2025-11-17
image: "/images/hill_function_example.png"
---

## 1. The Hill Function (Generative Form)

A typical Hill function:

$$
y = \alpha \cdot \frac{x^n}{k^n + x^n}
$$

* α — Maximum height (how tall the curve gets)  
* k — Midpoint (where it bends)  
* n — Hill coefficient (curvature / steepness)

Inside an MMM, the Hill function becomes the functional form for the “response curve” for each marketing channel. It looks something like this:

`sales ~ normal( sum(mu_j) + seasonality + promos + trend, sigma )`

Let's work through an example of what that would look like.

## 2. Simulate Some Data (“Before modeling, simulate the model” — McElreath)

```{r}
library(tidyverse)

set.seed(2025)

# True parameters
alpha_true <- 10
k_true     <- 3
n_true     <- 2

# Predictor
x <- seq(0, 30, length.out = 1e2)

# Hill function
hill <- function(x, alpha, k, n) {
  alpha * (x^n / (k^n + x^n))
}

y <- hill(x, alpha_true, k_true, n_true) + rnorm(length(x), 0, 0.5)

df <- tibble(x, y)

plot(df)
```

## 3. Fit the Hill Model Using r `brms::brm`

brm handles nonlinear formulas.

```{r cache = TRUE}
library(brms)

hill_model <- brm(
  bf(
    y ~ alpha * x^n / (k^n + x^n), ##hill function
    alpha + k + n ~ 1, ##model params  the ~ `1 is “Model each nonlinear parameter as its own intercept (no varying effects).”
    nl = TRUE #switches brms into nonlinear model
  ),
  data = df,
  family = gaussian(),
  prior = c(
    prior(normal(80, 3), nlpar = "alpha"), #max saturation level
    prior(normal(3, 2), nlpar = "k"), #half-max point - controls where the curve reaches 50% of a
    prior(normal(2, 1), nlpar = "n") # hill coefficient (steepness)
  ),
  iter = 2000,
  chains = 4,
  cores = 4
)

```

Under the hood the brms translates the formula to stan which looks like:
```
mu = alpha * pow(x, n) / (pow(k, n) + pow(x, n));
y ~ normal(mu, sigma);
alpha ~ normal(10, 3);
k ~ normal(3, 2);
n ~ normal(1, 1);
```

## 4. Review Posterior Summaries

```{r}
print(hill_model, digits = 2)
plot(hill_model)
posterior <- as.data.frame(hill_model)
```

You should see α, k, and n close to the true values 10, 3, and 1.

## 5. Posterior Predictive Curve

This mirrors McElreath’s "link" method in Statistical Rethinking:
```{r}
new_x <- tibble(x = seq(0, 30, length.out = 100))

pred <- rstantools::posterior_linpred(hill_model, newdata = new_x, transform = TRUE)

pred_mean  <- apply(pred, 2, mean)
pred_lower <- apply(pred, 2, quantile, 0.05)
pred_upper <- apply(pred, 2, quantile, 0.95)

plot_df <- new_x %>% 
  mutate(mean = pred_mean,
         lower = pred_lower,
         upper = pred_upper)

ggplot() +
  geom_point(data = df, aes(x, y), alpha = 0.5) +
  geom_line(data = plot_df, aes(x, mean), linewidth = 1.1) +
  geom_ribbon(data = plot_df, aes(x, ymin = lower, ymax = upper), alpha = 0.2) +
  theme_minimal() +
  labs(title = "Hill Function Fit using brms",
       y = "y", x = "x")
```

## Notes

This is not a GLM; it's explicitly nonlinear in the parameters.

Good priors matter: the Hill coefficient n is notoriously unstable without domain knowledge.

Plot prior predictive before sampling if possible.

Always check if posterior curves imply sane behavior for small or large x.

Think of α as “max plausible outcome,” k as “dose at half max,” and n as “bendiness.”